#!/usr/bin/env python3
# -*- mode: python -*-

"""pbench-tool-meister-client

Responsible for publishing the requested tool meister operation.  The
operation can be one of "start", "stop", or "send".
"""

import sys
import os
import json
import logging
import redis


# FIXME: move to common area
redis_host = "localhost"
# Port number is "One Tool" in hex 0x17001
redis_port = 17001

# FIXME: this should be moved to a shared area
channel = "tool-meister-chan"

# List of valid operations
operations = ("init", "start", "stop", "end", "send", "postprocess", "kill")


def main(argv):
    """Main program for the tool meister client.
    """
    PROG = os.path.basename(argv[0])
    logger = logging.getLogger(PROG)

    logger.setLevel(logging.INFO)
    sh = logging.StreamHandler()
    sh.setLevel(logging.INFO)
    shf = logging.Formatter("%(message)s")
    sh.setFormatter(shf)
    logger.addHandler(sh)

    try:
        group = argv[1]
    except IndexError:
        raise Exception("Missing group argument")
    try:
        directory = argv[2]
    except IndexError:
        raise Exception("Missing directory argument")
    try:
        operation = argv[3]
    except IndexError:
        raise Exception("Missing operation argument")
    else:
        if operation not in operations:
            raise Exception(
                "Unrecognized operation, '{}', valid operations are:"
                " {}".format(operation, operations)
            )
        elif operation == "postprocess":
            # We map the legacy "postprocess" action to the new "send" action.
            operation = "send"
        elif operation == "kill":
            # FIXME: we need to implement the gritty method of killing all the
            # tool meisters, locally and remotely, and ensuring they are all
            # properly shut down.
            return 0

    try:
        redis_server = redis.Redis(host=redis_host, port=redis_port, db=0)
    except Exception as e:
        logger.error(
            "Unable to connect to redis server, %s:%s: %s", redis_host, redis_port, e
        )
        return 2

    try:
        tm_pids_raw = redis_server.get("tm-pids")
        if tm_pids_raw is None:
            logger.error('Tool Meister PIDs key, "tm-pids", does not exist.')
            return 3
        tm_pids_str = tm_pids_raw.decode("utf-8")
        tm_pids = json.loads(tm_pids_str)
    except Exception as ex:
        logger.error('Unable to fetch and decode "tm-pids" key: %s', ex)
        return 4
    else:
        expected_pids = 0
        if "ds" in tm_pids:
            expected_pids += 1
        if "tm" in tm_pids:
            expected_pids += len(tm_pids["tm"])
        logger.debug("tm_pids = %r", tm_pids)

    # The published message contains three pieces of information:
    #   {
    #     "state": "< 'start' | 'stop' | 'send' | 'postprocess' | 'kill' >",
    #     "group": "< the tool group name for the tools to operate on >",
    #     "directory": "< the local directory path to store collected data >"
    #   }
    # The caller of tool-meister-client must be sure the directory argument
    # is accessible by the tool-data-sink.
    msg = dict(state=operation, group=group, directory=directory)
    try:
        num_present = redis_server.publish(channel, json.dumps(msg))
    except Exception:
        logger.exception("Failed to publish client message")
        ret_val = 1
    else:
        if num_present != expected_pids:
            logger.error(
                "Failed to publish to %d pids," " only encountered %d on the channel",
                expected_pids,
                num_present,
            )
            ret_val = 1
        else:
            ret_val = 0

    # FIXME: Setup a client channel to wait for an ACK that the message was
    # received.
    return ret_val


if __name__ == "__main__":
    status = main(sys.argv)
    sys.exit(status)

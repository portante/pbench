#!/usr/bin/env python3
# -*- mode: python -*-

"""pbench-tool-meister-stop

Responsible for ending persistent tools, collecting any requested system
information, recording any necessary metadata about the Tool Meisters, and
stopping all local/remote tool meisters, closing down the local data sink, and
finally the local redis server.
"""

import errno
import logging
import os
import signal
import sys
import time

from argparse import ArgumentParser
from pathlib import Path

from pbench.agent.constants import redis_port, cli_tm_channel_prefix
from pbench.agent.tool_meister_client import Client
from pbench.agent.utils import verify_sysinfo, info_log, verify_tool_group, BadToolGroup


def is_running(pid):
    """Is the given PID running?

    See https://stackoverflow.com/questions/7653178/wait-until-a-certain-process-knowing-the-pid-end
    """
    try:
        os.kill(pid, 0)
    except OSError as err:
        if err.errno == errno.ESRCH:
            return False
    return True


def main(_prog, parsed):
    """Main program for the tool meister stop CLI interface.

    Stopping the Tool Meisters involves four steps:

    1. End ("end") the run of the persistent tools

    2. Collect any requested system configuration information ("sysinfo")

    3. Record in the local metadata.log file all relevant metadata from the
    stop operation, including the timing to end the persistent tools, the
    timing to collect the system information, and any other data regarding the
    outstanding state of the Tool Meisters.

    4. Sends the "terminate" message to the redis server so that all connected
    services, tool-meisters, tool-data-sink, etc. will shutdown.  Once all
    services acknowledge the receipt of the "terminate" message, we look to
    ensure that the local Tool Data Sink and optional Tool Meister instance
    have shutdown by verifying their recorded pids are no longer seen on the
    local host.

    FIXME: previously we had a mode to "double-check" that the services all
    stopped by ssh'ing into all the local/remote hosts and inspecting the
    system for any lingering processes.  Should we offer a mode like that?
    """
    PROG = Path(_prog)
    logger = logging.getLogger(PROG.name)
    if os.environ.get("_PBENCH_TOOL_MEISTER_STOP_LOG_LEVEL") == "debug":
        log_level = logging.DEBUG
    else:
        log_level = logging.INFO
    logger.setLevel(log_level)
    sh = logging.StreamHandler()
    sh.setLevel(log_level)
    shf = logging.Formatter("%(message)s")
    sh.setFormatter(shf)
    logger.addHandler(sh)

    try:
        verify_tool_group(parsed.tool_group)
    except BadToolGroup as exc:
        logger.error(str(exc))
        return 1
    else:
        group = parsed.tool_group

    sysinfo = parsed.sysinfo
    if sysinfo is None:
        sysinfo = ""
    else:
        sysinfo_l, bad_l = verify_sysinfo(sysinfo)
        if bad_l:
            logger.error('invalid sysinfo option(s), "{}"', ",".join(bad_l))
            if not sysinfo_l:
                return 1
        if sysinfo_l:
            sysinfo = ",".join(sysinfo_l)
        else:
            sysinfo = ""

    interrupt = parsed.interrupt
    if interrupt and sysinfo:
        # Don't collect system information if the CLI invocation specified an
        # interrupt occured.
        logger.warning("system information not collected when --interrupt specified")
        sysinfo = ""

    try:
        full_hostname = os.environ["_pbench_full_hostname"]
        benchmark_run_dir = Path(os.environ["benchmark_run_dir"]).resolve(strict=True)
    except Exception:
        logger.exception("failed to fetch parameters from the environment")
        return 1

    try:
        redis_server_pid_file = (
            benchmark_run_dir / "tm" / f"redis_{redis_port:d}.pid"
        ).resolve(strict=True)
    except FileNotFoundError:
        # No Redis server, nothing to do.
        return 0

    # The Redis server is always running on the local host with the CLI.
    with Client(
        redis_host="localhost",
        redis_port=redis_port,
        channel_prefix=cli_tm_channel_prefix,
        logger=logger,
    ) as client:
        # First we end the persistent tools
        tool_dir = benchmark_run_dir / f"tools-{group}"
        try:
            tool_dir.mkdir(exist_ok=True)
        except Exception as exc:
            logger.error(
                'failed to create tool output directory, "{}": {}', tool_dir, exc
            )
        else:
            # FIXME - check return status.
            client.publish(group, tool_dir, "end", None)
        # Next we collect the system configuration information
        if sysinfo:
            sysinfo_path = benchmark_run_dir / "sysinfo" / "end"
            try:
                sysinfo_path.mkdir(parents=True)
            except Exception:
                logger.error(
                    "Unable to create sysinfo-dump directory base path: {}",
                    sysinfo_path,
                )
            else:
                logger.info("Collecting system information")
                info_log("Collecting system information")
                # FIXME - check return status.
                client.publish(group, sysinfo_path, "sysinfo", sysinfo)

        # Finally we terminate the running Tool Data Sinks and the Tool
        # Meisters, indicating if this termination is due to an interruption.
        ret_val = client.terminate(group, interrupt)

    if ret_val == 0:
        # The assumption/assertion here is that the tool meister "stop" command is
        # run on the same node as the Tool Data Sink. So we want to make sure
        # anything "local" to this stop command is shut down gracefully before we
        # report back to the user.  If Tool Meisters from remote nodes have
        # already reported that they have received the "terminate" message, then
        # we trust they will shutdown gracefully themselves.
        try:
            tds_pid_file = benchmark_run_dir / "tm" / "pbench-tool-data-sink.pid"
            try:
                pid_str = tds_pid_file.read_text()
            except OSError as exc:
                if exc.errno != errno.ENOENT:
                    raise
            else:
                tds_pid = int(pid_str)
                logger.debug("waiting for tool-data-sink (%d) to exit", tds_pid)
                while is_running(tds_pid):
                    time.sleep(0.1)
        except Exception:
            logger.exception("Exception encountered waiting for tool-data-sink")
            ret_val = 1

        try:
            ltm_pid_file = benchmark_run_dir / "tm" / f"tm-{group}-{full_hostname}.pid"
            try:
                pid_str = ltm_pid_file.read_text()
            except OSError as exc:
                if exc.errno != errno.ENOENT:
                    raise
            else:
                ltm_pid = int(pid_str)
                logger.debug("waiting for local tool-meister (%d) to exit", ltm_pid)
                while is_running(ltm_pid):
                    time.sleep(0.1)
        except Exception:
            logger.exception("Exception encountered waiting for local tool-meister")
            ret_val = 1

        # All was good so far, so we can terminate the redis server.
        try:
            try:
                pid_str = redis_server_pid_file.read_text()
            except OSError as exc:
                if exc.errno != errno.ENOENT:
                    raise
            else:
                redis_server_pid = int(pid_str)
                pid_exists = True
                while pid_exists:
                    try:
                        os.kill(redis_server_pid, signal.SIGTERM)
                    except ProcessLookupError:
                        pid_exists = False
                    else:
                        time.sleep(0.1)
        except Exception:
            logger.exception("Exception encountered terminating Redis server")
            ret_val = 1

    return ret_val


_NAME_ = "pbench-tool-meister-stop"

if __name__ == "__main__":
    parser = ArgumentParser(
        f"Usage: {_NAME_} [--sysinfo <list of system information items>]"
    )
    parser.add_argument(
        "--sysinfo",
        default=None,
        help="The list of system information items to be collected.",
    )
    parser.add_argument(
        "--interrupt",
        action="store_true",
        help="Whether or not the stop operation is in response to an interrupt.",
    )
    parser.add_argument(
        "tool_group", help="The tool group of items being run in the Tool Meisters."
    )
    parsed = parser.parse_args()
    status = main(sys.argv[0], parsed)
    sys.exit(status)
